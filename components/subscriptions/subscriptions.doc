Flow Chart:

graph TD
    A[User Frontend] -->|API Calls| B[Missing Subscription Routes]
    B -.->|Should Connect To| C[StripeService]
    C -->|Creates| D[Stripe Subscriptions]
    C -->|Manages| E[Stripe Customers]
    
    F[Stripe Webhooks] -->|Events| G[Webhook Handler]
    G -->|Updates| H[(Database)]
    
    H --> I[user_subscriptions]
    H --> J[subscription_items] 
    H --> K[subscription_payments]
    H --> L[vendor_subscriptions]
    
    I -->|Contains| M[User ID<br/>Stripe IDs<br/>Status<br/>Billing Periods<br/>Connect Balance Preference]
    J -->|Contains| N[Subscription Items<br/>Price IDs<br/>Persona Links<br/>Item Types]
    K -->|Contains| O[Payment Records<br/>Invoice IDs<br/>Payment Methods<br/>Amounts]
    
    D -->|Webhook Events| F
    E -->|Webhook Events| F
    
    P[SubscriptionManager Component] -->|Calls| A
    Q[Dashboard] -->|Shows| P
    
    style B fill:#ffcccc
    style B stroke:#ff0000
    classDef missing fill:#ffcccc,stroke:#ff0000

    __________________________________________________

# SUBSCRIPTION SYSTEM CORE DOCUMENTATION

## Overview
The subscription system is built as a modular architecture where individual subscription types are developed as separate modules, each with their own forms, permissions, business logic, and API endpoints. All modules share a common core infrastructure.

## Core Infrastructure (COMPLETED)

### Terms & Permissions Gate System
**ARCHITECTURAL PATTERN: Multi-Layer Access Control**

The subscription system implements a sophisticated 3-layer access control pattern that provides surgical precision for user access management:

**Layer 1: Page-Level Permissions (JWT-Based)**
- Controls access to entire dashboard sections
- Checked by middleware (`middleware/checklist.js`)
- Source of truth: JWT token permissions array
- Example: `userData.permissions.includes('vendor')` â†’ Can access vendor section

**Layer 2: Module-Level Permissions (Subscription-Based)**
- Controls access to specific subscription modules within dashboard sections
- Checked by individual components on mount
- Source of truth: Same JWT permissions, but checked per module
- Example: `userData.permissions.includes('sites')` â†’ Can access website module

**Layer 3: Terms-Level Gates (Version-Based)**
- Additional gate for module-specific terms acceptance
- Checked via dedicated API endpoints per subscription type
- Source of truth: `user_terms_acceptance` table with subscription_type context
- Example: Latest 'sites' terms accepted â†’ Full module access

**Implementation Pattern:**
```javascript
// Every subscription module follows this exact pattern:
const checkModuleAccess = async () => {
  // Step 1: Check JWT permission (immediate, no API call)
  const hasPermission = userData?.permissions?.includes(permissionName);
  
  if (hasPermission) {
    // Step 2: Check module-specific terms acceptance
    const termsResponse = await fetch(`/api/subscriptions/${moduleType}/terms-check`);
    const termsData = await termsResponse.json();
    
    if (termsData.termsAccepted) {
      setModuleState('dashboard'); // Full access
    } else {
      setModuleState('terms-required'); // Show terms modal
    }
  } else {
    setModuleState('signup'); // Show subscription signup workflow
  }
};

// Render logic:
if (moduleState === 'dashboard') return <ModuleDashboard />;
if (moduleState === 'terms-required') return <TermsModal />;
if (moduleState === 'signup') return <SignupWorkflow />;
```

**Benefits of This Architecture:**
- **Surgical Control**: Only relevant users see relevant terms
- **Graceful Degradation**: System works even if terms API fails
- **Consistent Pattern**: All subscription modules use identical logic
- **Security**: Users cannot bypass terms by manipulating frontend state
- **User Experience**: Smooth flows for both new and existing users
- **Maintainable**: Clear separation of concerns

**Required API Endpoints Per Module:**
- `GET /api/subscriptions/{type}/terms-check` - Check latest terms acceptance
- `POST /api/subscriptions/{type}/terms-accept` - Record terms acceptance
- Standard subscription management endpoints (signup, cancel, status)

**Database Requirements:**
- `terms_versions` table with `subscription_type` column
- `user_terms_acceptance` table with `subscription_type` column
- `user_permissions` table with module-specific permission columns

**Frontend State Management:**
- `moduleState`: 'loading' | 'dashboard' | 'terms-required' | 'signup'
- `termsData`: Latest terms content when acceptance required
- Consistent error handling and loading states

**Implementation Status:**
- âœ… **Shipping Module**: Complete implementation with terms-check endpoint
- âœ… **Sites Module**: Complete implementation with terms-check endpoint
- âœ… **Pattern Verified**: Both modules tested and working in production
- âœ… **Documentation**: Pattern documented for future module development

### Database Schema
Four main tables provide the foundation for all subscription types:

**`user_subscriptions`** - Main subscription records
- `id` - Primary key
- `user_id` - Links to users table
- `stripe_subscription_id` - Stripe subscription ID
- `stripe_customer_id` - Stripe customer ID
- `subscription_type` - ENUM('verification') - expandable for new types
- `status` - ENUM('active','canceled','past_due','unpaid','trialing','incomplete')
- `current_period_start/end` - Billing period tracking
- `cancel_at_period_end` - Cancellation preference
- `prefer_connect_balance` - Use Stripe Connect balance for payments
- Timestamps for created/updated/canceled

**`subscription_items`** - Granular subscription components
- Links subscriptions to Stripe price IDs
- `item_type` - ENUM('verification_base','verification_persona') - expandable
- `persona_id` - Links to artist_personas table when applicable
- Supports quantity-based pricing

**`subscription_payments`** - Payment history and tracking
- Complete payment audit trail
- `payment_method` - ENUM('card','connect_balance','other')
- Links to Stripe invoices and payment intents
- Billing period tracking per payment

**`vendor_subscriptions`** - Vendor-specific subscriptions (separate system)
- Different from user verification subscriptions
- Handles vendor platform fees and services

### Stripe Service Layer (COMPLETED)
Located: `api-service/src/services/stripeService.js`

**Core Methods:**
- `createOrGetCustomer()` - Customer management
- `createVerificationSubscription()` - Creates Stripe subscriptions with metadata
- `updateVerificationSubscription()` - Updates subscription items (persona changes)
- `processSubscriptionPaymentWithConnectBalance()` - Connect balance integration

**Key Features:**
- Comprehensive customer lifecycle management
- Metadata tracking for user_id, type, platform
- Payment behavior configuration
- Connect account integration

### Webhook System (COMPLETED)
Located: `api-service/src/routes/webhooks/stripe.js`

**Handled Events:**
- `customer.subscription.created` - Updates database on subscription creation
- `customer.subscription.updated` - Syncs subscription changes
- `customer.subscription.deleted` - Handles cancellations
- `invoice.created` - Attempts Connect balance payment first
- `invoice.payment_succeeded` - Records successful payments
- `invoice.payment_failed` - Handles payment failures

**Special Features:**
- Connect Balance Priority: Attempts to pay from Connect earnings before card
- Comprehensive error handling and logging
- Database synchronization with Stripe state

### Frontend Components (COMPLETED)
**SubscriptionManager Component** (`components/SubscriptionManager.js`)
- React component for subscription management UI
- Handles subscription creation, updates, cancellation
- Connect balance preference management
- Integrates with authentication and CSRF protection

**Dashboard Integration**
- Multiple subscription type placeholders in dashboard menu
- Slide-in panels for different subscription types
- Located: `components/dashboard/my-subscriptions/MySubscriptionsMenu.js`

## Unique System Features

### Connect Balance Integration
Users can pay subscription fees directly from their Stripe Connect earnings balance, providing a seamless experience for vendors who earn money on the platform.

### Persona-Based Subscriptions
Subscriptions can be linked to specific artist personas, enabling granular pricing models (base verification + per-persona fees).

### Flexible Item Types
The subscription_items table supports different item types, allowing for complex pricing structures within a single subscription.

### Multi-Payment Method Support
System tracks and supports multiple payment methods including cards, Connect balance, and other future payment types.

## Architecture Principles

### Modular Design
Each subscription type (verification, marketplace, website, ship, etc.) will be built as an independent module with:
- Dedicated API routes (`/api/subscriptions/{type}/*`)
- Custom forms and validation
- Type-specific business logic
- Individual permission systems
- Unique pricing models

### Shared Core
All modules utilize the same:
- Database schema (extensible enums)
- Stripe service layer
- Webhook handling system
- Base frontend components

### Build-as-Needed Approach
API routes and specific functionality are created when each subscription module is developed, ensuring clean separation and avoiding over-engineering.

## Current Status

### âœ… COMPLETED
- Database schema design and implementation
- Core Stripe service layer
- Webhook event handling
- Base frontend components
- Connect balance integration
- Payment tracking system

### ðŸ”„ IN DEVELOPMENT
- Individual subscription modules (starting with verification)

### ðŸ“‹ PLANNED MODULES
Based on dashboard menu structure:
- Verification Subscriptions
- Marketplace Subscriptions  
- Website Subscriptions
- Ship Subscriptions
- Additional modules as needed

## Development Notes
- Frontend calls to `/api/subscriptions/*` endpoints will be created per module
- Each module will extend the base subscription_type ENUM
- New item_types can be added to subscription_items as needed
- Webhook handlers are already generic enough to support new subscription types

---

## MODULE SECTIONS
(Individual subscription modules will be documented below as they are built)

---

# SHIPPING SUBSCRIPTION MODULE

## Overview
Pay-as-you-go shipping label service with stored payment method. Free subscription that enables users to purchase shipping labels on-demand with automatic payment processing.

## Business Model
- **Subscription**: $0/month - Just maintains valid payment method on file
- **Usage**: Pay-per-label at time of purchase (variable pricing)
- **Payment Priority**: Connect balance first (if available), then card on file
- **Permission**: Valid payment method = Can purchase labels

## Database Design

### Required Changes

**1. Extend subscription_type ENUM:**
```sql
ALTER TABLE user_subscriptions 
MODIFY subscription_type ENUM('verification', 'shipping_labels');
```

**2. Create shipping_label_purchases table:**
```sql
CREATE TABLE shipping_label_purchases (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  subscription_id BIGINT NOT NULL,
  shipping_label_id BIGINT NOT NULL,
  stripe_payment_intent_id VARCHAR(255),
  amount DECIMAL(10,2) NOT NULL,
  status ENUM('pending', 'succeeded', 'failed') DEFAULT 'pending',
  decline_reason VARCHAR(255) NULL,
  payment_method ENUM('card', 'connect_balance') DEFAULT 'card',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (subscription_id) REFERENCES user_subscriptions(id) ON DELETE CASCADE,
  FOREIGN KEY (shipping_label_id) REFERENCES shipping_labels(id) ON DELETE CASCADE,
  
  INDEX idx_subscription_id (subscription_id),
  INDEX idx_shipping_label_id (shipping_label_id),
  INDEX idx_payment_method (payment_method),
  INDEX idx_status (status)
);
```

### Existing Tables Integration

**user_subscriptions:**
- `subscription_type` = 'shipping_labels'
- `stripe_customer_id` = Customer with saved payment method
- `stripe_subscription_id` = NULL (no recurring billing)
- `prefer_connect_balance` = User's payment preference
- `status` = 'active' (valid card) or 'incomplete' (invalid card)

**shipping_labels (existing):**
- Links to purchases via `shipping_label_purchases.shipping_label_id`
- `vendor_transaction_id` = Used for Connect balance payments
- `cost` = Label cost for payment processing

**vendor_transactions (existing):**
- `transaction_type` = 'shipping_charge' for Connect balance payments
- Links to shipping_labels via `vendor_transaction_id`

## Payment Flow Architecture

### Dual Payment System
```
User Purchases Label
        â†“
Check: prefer_connect_balance && balance >= cost?
        â†“                    â†“
   YES: Connect Balance    NO: Card Payment
        â†“                    â†“
Create vendor_transaction  Create payment_intent
Link to shipping_labels    Create shipping_label_purchases
Update Connect balance     Link to shipping_labels
```

### Payment Method Priority
1. **Connect Balance** (if preferred and sufficient funds)
   - Deduct from Connect balance
   - Create `vendor_transactions` record
   - Link `shipping_labels.vendor_transaction_id`

2. **Card on File** (fallback or user preference)
   - Charge via Stripe payment_intent
   - Create `shipping_label_purchases` record
   - Link via `shipping_label_id`

## API Endpoints Required

### Subscription Management
- `POST /api/subscriptions/shipping/signup` - Create subscription + setup payment method
- `GET /api/subscriptions/shipping/my` - Get user's shipping subscription status
- `PUT /api/subscriptions/shipping/payment-method` - Update card on file
- `PUT /api/subscriptions/shipping/preferences` - Toggle Connect balance preference
- `DELETE /api/subscriptions/shipping/cancel` - Cancel subscription

### Label Purchasing Integration
- `POST /api/subscriptions/shipping/purchase-label` - Process label payment
- `GET /api/subscriptions/shipping/purchases` - Get purchase history
- `POST /api/subscriptions/shipping/refund` - Process refunds

## Frontend Components

### Core Components
1. **Signup Form** - Payment method setup with Stripe Elements
2. **Payment Method Manager** - Reusable card update component (store in /components/stripe/)
3. **Shipping Subscription Dashboard** - Standalone page showing:
   - Subscription status
   - Card on file (last 4 digits)
   - Connect balance preference toggle
   - Recent label purchases
   - Usage statistics

### Dashboard Integration
- Add to My Subscriptions menu
- Show subscription status
- Link to management page

## Webhook Handlers

### Payment Method Events
- `customer.source.expiring` â†’ Notify user
- `customer.source.expired` â†’ Disable shipping access
- `customer.source.updated` â†’ Re-enable access
- `setup_intent.succeeded` â†’ Activate subscription
- `setup_intent.setup_failed` â†’ Show error to user

### Payment Events
- `payment_intent.succeeded` â†’ Update shipping_label_purchases status
- `payment_intent.payment_failed` â†’ Record failure reason
- `charge.dispute.created` â†’ Handle label purchase disputes

## Permissions System

### New Permission: 'shipping'
- **Required for**: Purchasing shipping labels
- **Granted when**: Valid payment method on file
- **Revoked when**: Payment method expires/fails
- **Check location**: Shipping module integration points

## Financial Integration

### Unified Transaction View
Blend shipping purchases into existing financial dashboard:

**Connect Balance Payments:**
- Show as "Shipping Label (Connect)" in vendor_transactions

**Card Payments:**
- Show as two line items in unified view:
  1. "Shipping Label (Card Credit)" â†’ +$0.00 (neutral to Connect balance)
  2. "Shipping Label Purchase" â†’ -$labelCost (actual service cost)

### API Enhancement
Extend `/api/vendor-financials/transactions` to include:
- Query `shipping_label_purchases` for card payments
- Merge with existing `vendor_transactions`
- Sort chronologically
- Maintain Connect balance accuracy

## Integration Points

### Shipping Module Integration
- Check subscription status before label creation
- Call payment processing endpoint
- Handle payment failures gracefully
- Show decline reasons to user

### Error Handling
- **Card Declined**: Show specific decline reason (insufficient_funds, card_reported_stolen, etc.)
- **Connect Insufficient**: Auto-fallback to card
- **Both Failed**: Block label creation, prompt payment method update

## Security Considerations
- Payment method tokens stored in Stripe (not locally)
- CSRF protection on all payment endpoints
- Rate limiting on payment attempts
- Audit logging for all financial transactions

## Success Metrics
- Subscription signup conversion rate
- Payment method retention rate
- Connect vs Card usage ratio
- Label purchase success rate
- User satisfaction with payment flow

## Implementation Order
1. âœ… Database schema changes - COMPLETED & VERIFIED
   - All 4 core tables exist in database with correct structure
   - user_subscriptions.subscription_type includes 'shipping_labels' 
   - shipping_label_purchases table fully implemented
   - oaf_schema_current.sql updated to reflect database reality
2. âœ… Webhook handlers - COMPLETED & VERIFIED
   - All shipping payment webhooks implemented and tested
   - payment_intent.succeeded/failed handlers update shipping_label_purchases
   - setup_intent handlers for payment method lifecycle
   - Database mismatch fixed: subscription_type 'shipping' â†’ 'shipping_labels'
   - Webhook endpoint tested and responding correctly at /webhooks/stripe
   - Proper signature verification working (rejects invalid requests)
   - Ready for production Stripe webhook events
3. âœ… Core API endpoints (signup, management) - COMPLETED & VERIFIED
   - All 7 documented endpoints implemented in /routes/subscriptions/shipping.js
   - Additional smart endpoints: /activate, /update-payment-method
   - Proper route registration in server.js confirmed
   - Database queries fixed to use correct subscription_type
4. âœ… Frontend components (signup, dashboard) - COMPLETED & REDESIGNED
   - ShipSubscriptions.js rewritten with progressive checklist approach
   - Clean user flow: Card â†’ Terms â†’ Access (no complex branching)
   - Handles all edge cases: expired cards, admin access, existing customers
   - Uses global CSS variables for consistent OAF theme
   - Fixed API endpoint URLs to use production API service (api2.onlineartfestival.com)
   - Integrated with real terms acceptance API endpoints
5. âœ… Payment processing logic - COMPLETED & VERIFIED
   - Dual payment system (Connect balance â†’ card fallback) implemented
   - Proper table usage: shipping_label_purchases + vendor_transactions
   - Refund handling for both payment methods
6. âœ… Stripe Elements integration - COMPLETED & VERIFIED
   - Reusable StripeCardSetup component implemented in /components/stripe/
   - Proper setup intent flow with client_secret handling
   - Secure card collection with Stripe Elements v3
   - Clean UX with loading states and error handling
   - Uses setup intents (not payment intents) for card-on-file storage
7. âœ… Shipping module integration - INTEGRATION PLAN FINALIZED
   - Unified label creation system with conditional access
   - Single label library serving both order fulfillment and standalone shipping
   - Payment integration with subscription-aware processing
   - Component recycling for maximum efficiency
8. Financial dashboard integration
9. Testing and error handling

## Database Verification Status
âœ… **FOUNDATION CONFIRMED SOLID**
- Database tables match documentation specifications exactly
- Schema file synchronized with database reality  
- Foreign keys, indexes, and constraints properly implemented

## API Layer Verification Status
âœ… **API IMPLEMENTATION CONFIRMED EXCELLENT**
- Route organization clean: no scattered/rogue routes found
- All documented endpoints implemented with proper middleware
- Webhook integration sophisticated and complete
- Payment logic exactly matches documentation specifications
- Critical database mismatch resolved (subscription_type alignment)
- System ready for integration testing

## Terms Management Integration Plan
**DISCOVERED: Existing robust terms system in place**
- âœ… Current system: terms_versions + user_terms_acceptance tables
- âœ… Global middleware enforces general site terms acceptance
- âœ… Admin interface for terms management already built

**PLANNED EXTENSION: Subscription-Specific Terms**
- Extend user_terms_acceptance table with subscription_type column
- Add subscription context: ENUM('general', 'verification', 'shipping_labels', 'marketplace', 'website')
- Layered compliance model:
  * General terms (existing) â†’ Required for ALL site access
  * Subscription terms (new) â†’ Required only if user has that subscription type
- Middleware enhancement:
  * Check general terms (unchanged)
  * IF user has shipping subscription â†’ Check shipping terms acceptance
  * IF user has marketplace subscription â†’ Check marketplace terms acceptance
- Benefits:
  * No breaking changes to existing system
  * Contextual enforcement (only relevant terms required)
  * Terms updates can force re-acceptance per subscription type
  * Scalable for all future subscription modules

**Database Changes: âœ… COMPLETED**
- Extended user_terms_acceptance table with subscription_type column
- Extended terms_versions table with subscription_type column  
- Set existing terms to 'general' type (preserved archives)
- Added shipping terms v1.0 placeholder
- Updated /api/terms/check-acceptance to filter for general terms only
- Added efficient index for user + subscription type queries
- Schema file updated to reflect database reality
- Middleware now enforces general terms only, components handle subscription terms

**Implementation Status:**
- âœ… Database structure extended
- âœ… Schema file synchronized  
- âœ… API integration completed for subscription terms tracking
- âœ… Frontend logic updated to use subscription-specific terms

**Complete Terms Integration:**
- âœ… Enhanced `/my` endpoint returns `termsAccepted` status
- âœ… Added `/accept-terms` endpoint for subscription-specific terms acceptance
- âœ… Updated `/signup` logic to properly record terms acceptance
- âœ… Enhanced `/activate` endpoint to require terms acceptance before activation
- âœ… Frontend component updated to use real API terms data
- âœ… Progressive checklist now properly handles terms acceptance flow
- âœ… Component-level "mini-bouncer" architecture implemented

**Terms System Architecture Complete:**
- **Layer 1**: Middleware enforces general site terms
- **Layer 2**: Components enforce subscription-specific terms
- **Result**: Surgical terms control - only relevant users see relevant terms

## SHIPPING MODULE INTEGRATION PLAN

### Overview: Unified Label Creation System
Create one cohesive shipping system where both order fulfillment and standalone shipping feed into a single label library, with conditional access based on subscription permissions.

### Integration Architecture

**Two Entry Points, One System:**
1. **Order Fulfillment Path** (ManageOrders.js)
   - Conditional button: Has shipping permission â†’ "Add Label" | No permission â†’ "Get Access to Label Creation"
   - "Get Access" opens ShipSubscriptions modal for subscription signup
   - After signup, button flips to "Add Label" with full functionality

2. **Standalone Shipping Path** (ShipSubscriptions.js)  
   - Add label creation component to subscription dashboard
   - Same form/rate/purchase flow as order system
   - Creates unattached labels for general shipping needs

**Unified Label Library:**
- Single display component showing ALL labels (order + standalone)
- Used in both ManageOrders "Label Library" tab AND ShipSubscriptions dashboard
- Consistent UI/UX across both access points

### Component Recycling Strategy

**Reuse Existing Components:**
- **Label Creation Form**: Extract from ManageOrders, make reusable
- **Rate Fetching Logic**: Reuse `/api/shipping/get-label-rates` endpoint
- **Package Input Forms**: Reuse multi-package dimension/weight inputs
- **Label Library Display**: Reuse existing table/grid from ManageOrders
- **Payment Processing**: Integrate existing subscription payment flow

**New Components Needed:**
- **Conditional Access Button**: Smart button that checks permissions
- **Standalone Label Creator**: Wrapper component for ShipSubscriptions dashboard
- **Unified Label Display**: Component that works in both contexts

### Payment Integration Requirements

**Dual Payment Processing:**
- **Order Labels** (attached to sales):
  - Use Connect balance first (if enabled)
  - **Allow negative balance** (offset by future sale deposits)
  - Fallback to card on file
  - Process via modified `/api/shipping/process-batch`

- **Free-Standing Labels** (no sale backing):
  - Use Connect balance first (if enabled)
  - **Prevent negative balance** (balance might never recover)
  - Fallback to card on file  
  - Process via `/api/subscriptions/shipping/create-standalone-label`

**Per-Transaction Payment Method Override:**
- âœ… `force_card_payment` parameter bypasses Connect balance entirely
- âœ… Frontend checkbox: "Charge card directly (bypass balance)"
- âœ… Available on both order labels and standalone labels
- âœ… Only shown to users with stripe_connect permission
- âœ… Gives users complete control over payment method per transaction

**Payment Flow Integration:**
- Modify existing `/api/shipping/process-batch` to check subscription status
- Add subscription payment processing before label creation
- Handle payment failures gracefully with specific error messages
- Maintain existing batch processing capabilities

### Technical Implementation Plan

**Phase 1: Conditional Access (ManageOrders)**
- Add permission check to "Add Label" button
- Create "Get Access to Label Creation" alternative button
- Integrate ShipSubscriptions modal for signup flow
- Test permission-based button switching

**Phase 2: Standalone Label Creator (ShipSubscriptions)**
- Extract reusable components from ManageOrders label creation
- Add standalone label creation section to ShipSubscriptions dashboard
- Implement same rate fetching and form logic
- Store labels in same `shipping_labels` table with `order_id = NULL`

**Phase 3: Payment Integration** âœ… COMPLETED
- âœ… Modified `/api/shipping/process-batch` to require subscription check
- âœ… Added payment processing before label creation
- âœ… Implemented dual balance rules (order vs standalone)
- âœ… Updated error handling for payment failures
- âœ… Created `/api/subscriptions/shipping/create-standalone-label` endpoint
- âœ… Added per-transaction payment method override (`force_card_payment` parameter)
- âœ… Frontend checkboxes added for "Charge card directly (bypass balance)"

**Phase 4: Unified Label Library** âœ… COMPLETED
- âœ… Created `standalone_shipping_labels` table for standalone labels with `label_id` and `user_id`
- âœ… Updated `/create-standalone-label` endpoint to use new standalone table
- âœ… Created `purchaseStandaloneLabel` and `storeStandaloneLabel` functions in shipping service
- âœ… Created unified API endpoint `/api/subscriptions/shipping/all-labels` that UNIONs both tables
- âœ… Updated ManageOrders label library tab to use unified API with type indicators
- âœ… Updated ShipSubscriptions to display unified label library with payment method badges
- âœ… Added proper handling for standalone vs order labels (voiding restrictions, display differences)
- âœ… Consistent styling and functionality across both frontend entry points

### Database Considerations

**No Schema Changes Required:**
- `shipping_labels` table already supports both use cases
- `order_id = NULL` for standalone labels
- `vendor_transaction_id` for Connect balance payments
- `shipping_label_purchases` for card payments

**Payment Tracking:**
- Order labels: Track via existing `vendor_transactions` OR `shipping_label_purchases`
- Standalone labels: Track via `shipping_label_purchases` table
- Financial dashboard already configured to merge both sources

### Success Criteria

**Functional Requirements:**
- Users without shipping permission see "Get Access" button
- Users with shipping permission see "Add Label" button  
- Subscription signup immediately flips button access
- Both order and standalone labels appear in unified library
- Payment processing respects balance rules (order vs standalone)

**User Experience Requirements:**
- Seamless transition from "no access" to "full access"
- Consistent label creation experience across both entry points
- Unified label management regardless of creation source
- Clear payment method indication (Connect vs Card)

### COMPLETED: JWT Token Refresh Integration

**Issue Identified:**
- After shipping subscription signup, users needed to manually refresh the page for the "Get Access" button to change to "Add Label"
- JWT tokens were not automatically updated with new 'shipping' permission
- Admin users (who should have immediate access) were also affected by permission delays

**Solution Implemented:**
1. **Auth.js Updates:**
   - Added 'shipping' permission mapping to both JWT generation endpoints (login and refresh)
   - Ensures both initial login and token refresh include shipping permissions when present in database

2. **Frontend Token Refresh Integration:**
   - **ManageOrders**: `handleShippingModalClose()` now calls `refreshAuthToken()` before page reload
   - **ShipSubscriptions**: `handleTermsAcceptance()` now calls `refreshAuthToken()` immediately after successful terms acceptance
   - Both flows ensure JWT contains updated permissions before UI refresh

3. **Files Modified:**
   - `api-service/src/routes/auth.js`: Added shipping permission to both login (line 183) and refresh (line 298) token generation
   - `components/dashboard/manage-my-store/components/ManageOrders.js`: Added token refresh to modal close handler
   - `components/dashboard/my-subscriptions/components/ShipSubscriptions.js`: Added token refresh to terms acceptance flow

**Result:**
- Admin users immediately see "Add Label" buttons (no signup required)
- Regular users see instant button flip from "Get Access" to "Add Label" after signup completion
- No manual page refresh required for permission updates

---

# WEBSITE SUBSCRIPTION MODULE

## Overview
Monetize the existing custom sites/artist sites system by wrapping it in subscription tiers. Transform the current free website creation into a paid service with multiple feature levels.

## Current Sites System Analysis
- âœ… **Existing Infrastructure**: Full sites table, domain management, themes, subdomain routing
- âœ… **Permission System**: `manage_sites` permission controls access
- âœ… **Frontend Management**: Complete SitesManagement.js component
- âœ… **Domain Features**: Custom domain support, DNS validation, SSL handling

## Current Limitations to Address
- **Hardcoded Limits**: "1 site per artist, unlimited for admins" 
- **No Monetization**: Free access for anyone with permissions
- **No Feature Tiers**: All users get identical capabilities

## Planning Discussion

### User Feedback & Requirements:

**1. Hidden Free Plan:**
- All existing sites automatically moved to hidden "free" tier
- Admin sites default to free tier (for marketing campaigns, landing pages, catalog fronts)
- Maintains current signin subdomain functionality
- Not visible to regular users in subscription selection

**2. Flexible Pricing & Promotions:**
- Base subscription tiers with discount capability
- Promotional codes: 50% off for 6 months, first month free, $1/month for 2 months
- Need promo code system integration

**3. Revised Tier Structure:**
- **Free (Hidden)**: For existing sites, admin use, marketing campaigns
- **Basic**: Subdomain only + 2 templates
- **Pro**: Custom domain + more templates  
- **Premium**: Domain + templates + addons package + priority support
- **Add-ons**: Additional addons, custom templates, setup assistance, extra sites

**4. Enhanced Status Management:**
- Existing: draft, active, inactive, suspended, deleted
- **New**: suspended_violation, suspended_finance

### Missing Components Analysis:

**âœ… COMPLETED: Enhanced Status System**
- Database: Updated sites table ENUM to include `suspended_violation` and `suspended_finance`
- Schema file synchronized with database reality

**Implementation Phases:**

**Phase 1: Promo Codes** âœ… COMPLETED
- âœ… Database: Universal `discounts` table with all subscription types support
- âœ… API: Discount calculation engine with stacking/chaining logic
- âœ… Business Logic: Priority-based conflict resolution
- âœ… Admin Tools: Create/delete discount endpoints

**Phase 1 Implementation Details:**

**Database Schema:**
```sql
CREATE TABLE discounts (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  subscription_type ENUM('website', 'shipping_labels', 'verification'),
  discount_code VARCHAR(100) NOT NULL,
  discount_type ENUM('percentage', 'fixed_amount', 'free_months', 'free_addon'),
  discount_value DECIMAL(10,2) NOT NULL,
  priority INT DEFAULT 10,
  can_stack TINYINT(1) DEFAULT 1,
  can_chain TINYINT(1) DEFAULT 0,
  valid_from/valid_until TIMESTAMP,
  is_active TINYINT(1) DEFAULT 1
);
```

**API Endpoints:**
- `GET /api/sites/discounts/calculate?subscription_type=website` - Calculate active discounts
- `POST /api/sites/discounts` - Create discount (admin only)
- `DELETE /api/sites/discounts/:id` - Remove discount (admin only)

**Discount Logic:**
- Priority-based: Lower number = higher priority
- Stacking: If ANY discount has can_stack=no, use highest priority only
- Chaining: can_chain=no prevents adding same discount_type if one exists
- Universal: Works for website, shipping_labels, verification subscriptions

**Phase 2: Templates Build & Design** âœ… COMPLETED
- âœ… Database: `website_templates` table with tier restrictions
- âœ… Sites Integration: Added `template_id` column to sites table
- âœ… API: Complete template selection and management endpoints
- âœ… Admin Tools: Template creation and management system

**Phase 2 Implementation Details:**

**Database Schema:**
```sql
CREATE TABLE website_templates (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  template_name VARCHAR(100) NOT NULL,
  template_slug VARCHAR(100) UNIQUE NOT NULL,
  css_file_path VARCHAR(500) NOT NULL,
  tier_required ENUM('free', 'basic', 'pro', 'premium') DEFAULT 'free',
  preview_image_url VARCHAR(500),
  display_order INT DEFAULT 0
);

ALTER TABLE sites ADD COLUMN template_id BIGINT DEFAULT 1;
```

**Template Selection Flow:**
1. User visits template gallery: `GET /api/sites/templates`
2. User selects template: `PUT /api/sites/template/5` 
3. System updates: `sites.template_id = 5`
4. Next page load: Looks up template CSS file and applies new styling
5. **Same data, completely new look!**

**API Endpoints:**
- `GET /api/sites/templates` - Browse available templates
- `GET /api/sites/templates/:id` - Get template details
- `PUT /api/sites/template/:id` - Apply template to user's site
- `POST /api/sites/templates` - Create new template (admin only)

**Template System Architecture:**
- **Separation of Concerns**: Templates (CSS) vs Site Data (content)
- **Simple Relationship**: Each site points to one template via foreign key
- **Tier-Based Access**: Templates restricted by subscription level
- **Performance**: Just one JOIN query to get template info

**Phase 3: Addons & Template Tiers** âœ… COMPLETED
- âœ… Database: `website_addons` and `site_addons` tables with pricing and tier restrictions
- âœ… Addon Modules: 7 blank addon modules created in `components/sites-modules/` (moved from pages to prevent Next.js build conflicts)
- âœ… API: Complete addon marketplace and management endpoints
- âœ… Many-to-Many Relationship: Sites can have multiple addons
- âœ… Database Paths Updated: All addon_script_path entries updated to `/components/sites-modules/` location

**Phase 3 Implementation Details:**

**Database Schema:**
```sql
CREATE TABLE website_addons (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  addon_name VARCHAR(100) NOT NULL,
  addon_slug VARCHAR(100) UNIQUE NOT NULL,
  addon_script_path VARCHAR(500) NOT NULL,
  tier_required ENUM('free', 'basic', 'pro', 'premium') DEFAULT 'basic',
  monthly_price DECIMAL(10,2) DEFAULT 0.00,
  display_order INT DEFAULT 0
);

CREATE TABLE site_addons (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  site_id BIGINT NOT NULL,
  addon_id BIGINT NOT NULL,
  is_active TINYINT(1) DEFAULT 1,
  activated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY unique_site_addon (site_id, addon_id)
);
```

**Addon Modules Created:**
- Email Collection ($5/month, Basic tier)
- Social Posting ($10/month, Pro tier)
- Wholesale Pricing ($15/month, Pro tier)
- Etsy Connector ($20/month, Premium tier)
- Amazon Connector ($25/month, Premium tier)
- Walmart Connector ($25/month, Premium tier)
- TikTok Connector ($20/month, Premium tier)

**Site Loading Flow:**
1. Site loads â†’ `GET /api/sites/my-addons` returns active addon script paths
2. Site dynamically loads addon scripts: `/components/sites-modules/email-collection.js`
3. Each addon initializes and adds its functionality
4. **Same site, enhanced with modular features!**

**API Endpoints:**
- `GET /api/sites/addons` - Browse addon marketplace
- `GET /api/sites/my-addons` - Get user's active addons with script paths
- `POST /api/sites/addons/:id` - Add addon to user's site
- `DELETE /api/sites/addons/:id` - Remove addon from user's site
- `POST /api/sites/addons` - Create new addon (admin only)

**Addon System Architecture:**
- **Modular Loading**: Addons load dynamically based on user's active subscriptions
- **Many-to-Many**: Sites can have multiple addons, addons can be on multiple sites
- **Pricing Integration**: Each addon has individual monthly pricing
- **Tier Restrictions**: Addons restricted by subscription level

**Phase 4: Customer Interface** âœ… COMPLETED
- âœ… WebsiteSubscriptions.js component with permission-based routing
- âœ… Terms acceptance integration with subscription-specific terms system
- âœ… Frontend permission checks ('sites' permission for dashboard access)
- âœ… Refined Pricing Tiers: Starter Plan ($14.99), Professional Plan ($24.95), Business Plan ($49.95), Promoter Plan ($49.95)
- âœ… Plan Descriptions: Compelling mini-descriptions for each tier explaining value proposition
- âœ… Visual Layout: Promoter Plan centered on separate row for distinction from artist-focused plans
- âœ… Complete Backend API Integration: 5 functional endpoints in modular routes file
- âœ… Subscription Signup Flow: Real payment integration placeholder with permission granting
- âœ… Cancellation System: Dashboard cancel button with confirmation and permission revocation
- ðŸ”„ **Pending**: Sites dashboard enhancement with full site management integration

**Phase 4 Architecture Notes:**

**Dual-Layer Subscription System:**
We discovered that instead of rigid subscription tiers, we can use a flexible addon-based approach:

**User-Level Permissions** (Account-wide functionality):
- `custom_domain` ($10/month) - Use custom domains on any site
- `second_site` ($15/month) - Create multiple sites beyond 1-site limit  
- `priority_support` ($5/month) - Priority customer support
- `white_label` ($8/month) - Remove "Powered by OAF" branding
- `api_access` ($20/month) - Developer API access
- `advanced_analytics` ($12/month) - Detailed site analytics

**Site-Level Addons** (Per-site functionality):
- `email_collection` ($5/month) - Email signup forms for this site
- `social_posting` ($10/month) - Auto-post to social media from this site
- `etsy_connector` ($20/month) - Etsy sync for this site
- `wholesale_pricing` ($15/month) - Bulk pricing for this site
- Plus all existing addons in addon system

**Phase 4 Implementation Details:**

**Frontend Component Architecture:**
```javascript
// WebsiteSubscriptions.js - Main component with permission-based routing
const hasSitesPermission = userData?.permissions?.includes('sites');

// Flow:
// 1. No 'sites' permission â†’ Show pricing tiers with signup buttons
// 2. Has 'sites' permission â†’ Check terms acceptance
// 3. Terms not accepted â†’ Show terms modal (blocks dashboard)
// 4. Terms accepted â†’ Show website dashboard with sites management
```

**Permission & Terms Integration:**
- âœ… **'sites' Permission**: Added to user_permissions table and JWT generation
- âœ… **Terms System**: Extended with 'sites' subscription type and terms content
- âœ… **Terms Check**: Component checks latest terms acceptance before dashboard access
- âœ… **Terms Modal**: Forces acceptance of updated terms to continue

**Database Extensions:**
```sql
-- Permission system
ALTER TABLE user_permissions ADD COLUMN sites TINYINT(1) DEFAULT 0;

-- Terms system  
ALTER TABLE terms_versions MODIFY subscription_type ENUM(..., 'sites');
ALTER TABLE user_terms_acceptance MODIFY subscription_type ENUM(..., 'sites');

-- Added website subscription terms v1.0
INSERT INTO terms_versions (title, content, version, subscription_type, is_current) 
VALUES ('Website Subscription Terms', '...', '1.0', 'sites', 1);
```

**Frontend State Management:**
- Permission-based component rendering
- Terms acceptance state tracking
- Modal state management for signup/terms
- Mocked API calls ready for backend integration

**Updated Pricing Tiers (December 2024):**

**Starter Plan - $14.99/month**
- Description: "Simple setup, core features, great for getting started"
- Features: 1 Website, Subdomain included, Basic templates, Use your OAF data to build a complete site in minutes, Community support

**Professional Plan - $24.95/month (Most Popular)**
- Description: "Build a professional brand, grow your online presence, connect with your shoppers"
- Features: Everything in Starter Plan, Use your Custom domain, Premium design templates, Access to premium addons, Priority Support, Access to custom design services

**Business Plan - $49.95/month**
- Description: "Take your art business to the next level with marketplace connectors, wholesale access and brand building tools"
- Features: Everything in Starter and Professional Plans, Access to multiple websites with custom domains, Premium addons and marketplace connectors, Wholesale pricing, Dedicated support, Core analytics

**Promoter Plan - $49.95/month (Centered on own row)**
- Description: "Grow your event and promote your artists with tools tailored to help you drive more traffic to your event participants"
- Features: Includes all artist pro features, plus Tools to help you sell merch, Application and jury tools, Invoicing and acceptance management, Excel at SEO and web optimization

**Backend Implementation Details (December 2024):**

**Modular API Architecture:**
- **Route File**: `api-service/src/routes/subscriptions/sites.js`
- **Server Registration**: `/api/subscriptions/sites` in `server.js`
- **Self-Contained**: All sites subscription logic in single modular file
- **Consistent Pattern**: Follows same structure as shipping subscription routes

**Permission Integration:**
- **Database**: `user_permissions.sites` column controls access
- **JWT**: Sites permission included in token generation (auth.js)
- **Frontend**: Permission-based component routing
- **Lifecycle**: Permission granted on signup, revoked on cancellation

**Terms System Integration:**
- **Database Terms**: ID 5, "Website Subscription Terms" v1.0 active
- **Subscription-Specific**: Uses 'sites' subscription_type
- **Enforcement**: Terms acceptance required before dashboard access
- **Tracking**: Full acceptance history in `user_terms_acceptance` table

**API Endpoints Built (December 2024):**
- âœ… `GET /api/subscriptions/sites/terms-check` - Check if user accepted latest 'sites' terms
- âœ… `POST /api/subscriptions/sites/terms-accept` - Record terms acceptance for sites subscription

- âœ… `POST /api/subscriptions/sites/signup` - Create subscription and grant 'sites' permission
- âœ… `POST /api/subscriptions/sites/cancel` - Cancel subscription and revoke 'sites' permission
- âœ… **BONUS**: `GET /api/subscriptions/sites/status` - Get current subscription status

**Implementation Strategy:**
âœ… **Infrastructure Complete**: Permission system, addon system, discount system, terms system all ready
âœ… **Frontend Complete**: Component with permission routing, terms integration, pricing UI, subscription lifecycle management
âœ… **Backend APIs Complete**: All 5 endpoints functional with modular routes architecture
âœ… **Database Integration**: Terms system working, permission granting/revoking functional
ðŸ”„ **Final Phase - Sites Dashboard Enhancement**: 
1. **Dashboard Integration**: Integrate existing SitesManagement.js component into subscription dashboard
2. **Template System**: Connect template selection system (`/api/sites/templates`) to dashboard
3. **Addon Management**: Connect addon management system (`/api/sites/addons`) to dashboard  
4. **Tier Restrictions**: Implement subscription tier feature restrictions (Basic vs Pro vs Business vs Promoter)
5. **Site Management**: Add site creation/editing functionality within subscription context
6. **Feature Gating**: Enforce plan limits (1 site for Starter, custom domains for Pro+, etc.)

**Billing Model:**
```
Total Monthly Bill = Base ($9.99) + User Permissions + Site Addons + Discounts
Example: $9.99 + $10 (custom_domain) + $5 (email on site A) + $10 (social on site B) - $2 (loyalty discount) = $32.99
```

**Benefits:**
- Pay-for-what-you-use pricing
- Flexible user customization  
- Easy upselling opportunities
- Bundle discounts via existing discount system
- No rigid tier limitations

---
